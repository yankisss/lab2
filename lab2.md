## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2501`

#### Выполнил: `Закалюкина Яна Андреевна`

#### Вариант: `7`

### Cодержание:

[Задача 1](#Задача-1)
- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

[Задача 2](#Задача-2)
- [Постановка задачи](#7-постановка-задачи)
- [Входные и выходные данные](#8-входные-и-выходные-данные)
- [Выбор структуры данных](#9-выбор-структуры-данных)
- [Алгоритм](#10-алгоритм)
- [Программа](#11-программа)
- [Анализ правильности решения](#12-анализ-правильности-решения)

[Задача 3](#Задача-3)
- [Постановка задачи](#13-постановка-задачи)
- [Входные и выходные данные](#14-входные-и-выходные-данные)
- [Выбор структуры данных](#15-выбор-структуры-данных)
- [Алгоритм](#16-алгоритм)
- [Программа](#17-программа)
- [Анализ правильности решения](#18-анализ-правильности-решения)

[Задача 4](#Задача-4)
- [Постановка задачи](#19-постановка-задачи)
- [Входные и выходные данные](#20-входные-и-выходные-данные)
- [Выбор структуры данных](#21-выбор-структуры-данных)
- [Алгоритм](#22-алгоритм)
- [Программа](#23-программа)
- [Анализ правильности решения](#24-анализ-правильности-решения)

### Задача 1
### 1. Постановка задачи

> Посмотреть, какие значения принимает последовательность при разных a0 и n, вывести закономерность, по которой строится последовательность и запрограммировать ее.

### 1. Входные и выходные данные

#### Данные на вход

На вход программа получает два числа
Первая строка: натуральное число n — количество элементов последовательности.
Вторая строка: n целых чисел — элементы последовательности.

|             |        Тип        | min значение | max значение |
|-------------|-------------------|--------------|--------------|
|      n      | Натуральное число |       1      |      +∞      |
| A (Число 2) | Натуральное число |       1      |      +∞      |
| B (Число 3) | Натуральное число |       1      |      +∞      |
| C (Число 4) | Натуральное число |       1      |      +∞      |


#### Данные на выход

Т.к. программа должна вывести количество покупателей, кторые смогут купить бананы, то на выход мы получим
единственное целое положительное число.

|             |            Тип            | min значение | max значение |
|-------------|---------------------------|--------------|--------------|
| R (Число 1) | Целое положительное число |       0      |       3      |

### 3. Выбор структуры данных

Программа получает 4 натуральных числа и выводит еще 1. Поэтому для их хранения
можно выделить 5 переменных (`x`, `a`, `b`, `c`, `r`) типа `int`.

|             | название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| X (Число 1) |         `x`         |    `int`     |
| A (Число 2) |         `a`         |    `int`     |
| B (Число 3) |         `b`         |    `int`     |
| C (Число 4) |         `c`         |    `int`     |
| R (Число 5) |         `r`         |    `int`     |


### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает четыре натуральных числа, обозначенные как `x`, `a`, `b`, `c`.
   Затем инициализируется переменная `r = 0`, которая будет хранить количество покупателей, получивших бананы.

3. **Сравнение чисел:**  
   - Программа сравнивает значения `x` и `a`.
     1) Если `x` больше или равно `a`: программа переходит к следующему шагу для работы с `x`.
        `x = x - a`
        `r = r + 1`
     2) Если `x` меньше `a`: `x` остается без изменений
   - Программа сравнивает значения `x` и `b`. 
     1) Если `x` больше или равно `b`: программа переходит к следующему шагу для работы с `x`.
        `x = x - b`
        `r = r + 1`
     2) Если `x` меньше `b`: `x` остается без изменений
   - Программа сравнивает значения `x` и `c`. 
     1) Если `x` больше или равно `c`: программа переходит к следующему шагу для работы с `x`.
        `x = x - c`
        `r = r + 1`
     2) Если `x` меньше `c`: `x` остается без изменений

4. **Вывод результата:**  
   На экран выводится значение `r`.

#### Блок-схема

```mermaid
flowchart TD
    A([Начало]) --> B[/Ввод x, a, b, c/]
    B --> C[/r = 0/]

    C --> D{x >= a?}
    D -->|Да| E[x = x - a<br>r = r + 1]
    D -->|Нет| F1[Пропустить покупателя a]
    E --> G{x >= b?}
    F1 --> G

    G -->|Да| H[x = x - b<br>r = r + 1]
    G -->|Нет| F2[Пропустить покупателя b]
    H --> I{x >= c?}
    F2 --> I

    I -->|Да| J[x = x - c<br>r = r + 1]
    I -->|Нет| F3[Пропустить покупателя c]
    J --> K[/Вывод r/]
    F3 --> K

    K --> Z([Конец])


```

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Main {
    // Объявляем объект класса Scanner для ввода данных
    public static Scanner in = new Scanner(System.in);
    // Объявляем объект класса PrintStream для вывода данных
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        // Считывание значений x, a, b, c
        System.out.print("Количество бананов в магазине: ");
        int x = in.nextInt();

        System.out.print("Сколько бананов планирует купить покупатель A: ");
        int a = in.nextInt();

        System.out.print("Сколько бананов планирует купить покупатель B: ");
        int b = in.nextInt();

        System.out.print("Сколько бананов планирует купить покупатель C: ");
        int c = in.nextInt();

        // Инициализация счётчика покупателей
        int r = 0;

        // Проверка условий покупки
        if (x >= a) {
            x -= a; // Покупатель купил
            r++;    // Увеличиваем счётчик
        }

        if (x >= b) {
            x -= b; // Покупатель купил
            r++; // Увеличиваем счётчик
        }

        if (x >= c) {
            x -= c; // Покупатель купил
            r++;// Увеличиваем счётчик
        }

        // Вывод результата
        System.out.println("Количество человек, купивших бананы: " + r);


    }
}
```

###  6. Анализ правильности решения

Программа работает корректно на всем множестве решений.

1. Тест на `X > A > B > C`:

    - **Input**:
        ```
        30 15 14 13
        ```

    - **Output**:
        ```
        2
        ```
2. Тест на `X > A < B > C`:

    - **Input**:
        ```
        50 20 24 3
        ```

    - **Output**:
        ```
        3
        ```
3. Тест на `X > A < B < C`:

    - **Input**:
        ```
        40 10 12 20
        ```

    - **Output**:
        ```
        2
        ```
4. Тест на `X < A > B > C`:

    - **Input**:
        ```
        10 15 6 3
        ```

    - **Output**:
        ```
        2
        ```
5. Тест на `X < A < B < C`:

    - **Input**:
        ```
        5 6 10 13
        ```

    - **Output**:
        ```
        0
        ```
### Задача 2
### 7. Постановка задачи

> Дана последовательность из n чисел. Выведите индекс последнего элемента, перед которым количество положительных и количество отрицательных элементов встретились поровну. Если такого элемента нет – вывести "NO".

### 8. Входные и выходные данные

#### Данные на вход

На вхлд программа получает две строки
Первая строка: натуральное число n — количество элементов последовательности.
Вторая строка: n целых чисел — элементы последовательности.

|                   |        Тип        | min значение | max значение |
|-------------------|-------------------|--------------|--------------|
|         n         | Натуральное число |       1      |      100     |
|    a₁, a₂, … aₙ   |    Целые числа    |      −10⁹     |      10⁹     |


#### Данные на выход

На выход мы получим единственное целое положительное число.

|             |            Тип            | min значение | max значение |
|-------------|---------------------------|--------------|--------------|
|      R      |   Индекс или строка "NO"  |       1      |    100 (n)   |

### 9. Выбор структуры данных

Понадобятся следующие переменные:

|           Смысл           | Название | Тип     |
| ------------------------- | -------- | ------- |
|    Количество элементов   |    `n`   |  `int`  |
| Массив последовательности |   `A[]`  |  `int[]`|
|    Счётчик положительных  |   `pos`  |  `int`  |
|    Счётчик отрицательных  |   `neg`  |  `int`  |
|     Результат (индекс)    |   `res`  |  `int`  |



### 10. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает две строки, обозначенные как `x`, `a`, `b`, `c`.
   Затем инициализируется переменная `r = 0`, которая будет хранить количество покупателей, получивших бананы.

3. **Сравнение чисел:**  
   - Программа сравнивает значения `x` и `a`.
     1) Если `x` больше или равно `a`: программа переходит к следующему шагу для работы с `x`.
        `x = x - a`
        `r = r + 1`
     2) Если `x` меньше `a`: `x` остается без изменений
   - Программа сравнивает значения `x` и `b`. 
     1) Если `x` больше или равно `b`: программа переходит к следующему шагу для работы с `x`.
        `x = x - b`
        `r = r + 1`
     2) Если `x` меньше `b`: `x` остается без изменений
   - Программа сравнивает значения `x` и `c`. 
     1) Если `x` больше или равно `c`: программа переходит к следующему шагу для работы с `x`.
        `x = x - c`
        `r = r + 1`
     2) Если `x` меньше `c`: `x` остается без изменений

4. **Вывод результата:**  
   На экран выводится значение `r`.

#### Блок-схема
```mermaid
flowchart TD
 A([Начало]) --> B[/Ввод n и массива/]
 B --> C[/pos = 0, neg = 0, res = -1/]

 C --> D{ i от 1 до n? }
 D -->|Нет| Z([Конец])

 D -->|Да| E{pos == neg?}
 E -->|Да| F[res = i]
 E -->|Нет| G[Пропустить]

 F --> H{arr[i] > 0?}
 G --> H

 H -->|Да| I[pos = pos + 1]
 H -->|Нет| J{arr[i] < 0?}

 J -->|Да| K[neg = neg + 1]
 J -->|Нет| L[Ничего не делать]

 I --> M[Следующий i]
 K --> M
 L --> M

 M --> D

```

### 11. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        // Ввод количества элементов
        int n = in.nextInt();
        int[] A = new int[n];

        for (int i = 0; i < A.length; i++) {
            A[i] = in.nextInt();
        }
        
        int pos = 0; // количество положительных
        int neg = 0; // количество отрицательных
        int res = 0; // искомый индекс

        // Перебор элементов
        for (int i = 0; i < A.length; i++) {
            // Проверяем условие перед элементом i+1
            if (pos == neg) {
                res = i + 1; 
            }
            // Анализ текущего элемента
            if (A[i] > 0) pos++;
            else if (A[i] < 0) neg++;
        }
        // Вывод результата
        if (res == 1) {
            System.out.println("NO");
        } else {
            System.out.println(res);
        }
    }
}
```

###  12. Анализ правильности решения

Программа работает корректно на всем множестве решений.

1. Тест на `X > A > B > C`:

    - **Input**:
        ```
        30 15 14 13
        ```

    - **Output**:
        ```
        2
        ```
2. Тест на `X > A < B > C`:

    - **Input**:
        ```
        50 20 24 3
        ```

    - **Output**:
        ```
        3
        ```
3. Тест на `X > A < B < C`:

    - **Input**:
        ```
        40 10 12 20
        ```

    - **Output**:
        ```
        2
        ```
4. Тест на `X < A > B > C`:

    - **Input**:
        ```
        10 15 6 3
        ```

    - **Output**:
        ```
        2
        ```
5. Тест на `X < A < B < C`:

    - **Input**:
        ```
        5 6 10 13
        ```

    - **Output**:
        ```
        0
        ```
### Задача 3
### 13. Постановка задачи

> Рассматривается следующая последовательность: x n+1 = (a∗x n + c) mod m,x 0 = x0
Требуется определить длину цикла этой последовательности – наименьшее положительное целое число p, такое, что начиная с некоторого шага значения повторяются с периодом p (после, возможно, непустого начального отрезка). Вывести на экран длину периода.

### 14. Входные и выходные данные

#### Данные на вход

На вход программа получает одну строку: четыре целых числа a, c, m (m > 0), x0

| Имя  | Значение          | Ограничения |
| ---- | ----------------- | ----------- |
| `a`  | множитель         | любое целое |
| `c`  | добавка           | любое целое |
| `m`  | модуль            | `m > 0`     |
| `x0` | начальный элемент | любое целое |


#### Данные на выход

На выход мы получим единственное целое положительное число.

| Имя | Значение                         |
| --- | -------------------------------- |
| `p` | длина периода последовательности |


### 15. Выбор структуры данных

Понадобятся следующие переменные:

| Переменная   | Значение                                                            | Тип     |
| ------------ | ------------------------------------------------------------------- | ------- |
| `a, c, m, x` | параметры последовательности                                        | `long`  |
| `visited`    | массив размера `m`, хранящий шаг первого появления каждого значения | `int[]` |
| `step`       | номер текущего шага                                                 | `int`   |




### 16. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает две строки, обозначенные как `x`, `a`, `b`, `c`.
   Затем инициализируется переменная `r = 0`, которая будет хранить количество покупателей, получивших бананы.

3. **Сравнение чисел:**  
   - Программа сравнивает значения `x` и `a`.
     1) Если `x` больше или равно `a`: программа переходит к следующему шагу для работы с `x`.
        `x = x - a`
        `r = r + 1`
     2) Если `x` меньше `a`: `x` остается без изменений
   - Программа сравнивает значения `x` и `b`. 
     1) Если `x` больше или равно `b`: программа переходит к следующему шагу для работы с `x`.
        `x = x - b`
        `r = r + 1`
     2) Если `x` меньше `b`: `x` остается без изменений
   - Программа сравнивает значения `x` и `c`. 
     1) Если `x` больше или равно `c`: программа переходит к следующему шагу для работы с `x`.
        `x = x - c`
        `r = r + 1`
     2) Если `x` меньше `c`: `x` остается без изменений

4. **Вывод результата:**  
   На экран выводится значение `r`.

#### Блок-схема

```mermaid
flowchart TD

A([Начало]) --> B[/Ввод n и массива/]
B --> C[/pos = 0, neg = 0, res = -1/]

C --> D{ i от 1 до n? }
D -->|Нет| Z([Конец])

D -->|Да| E{pos == neg?}
E -->|Да| F[res = i]
E -->|Нет| G[Пропустить]

F --> H{arr[i] > 0?}
G --> H

H -->|Да| I[pos = pos + 1]
H -->|Нет| J{arr[i] < 0?}

J -->|Да| K[neg = neg + 1]
J -->|Нет| L[Ничего не делать]

I --> M[Следующий i]
K --> M
L --> M

M --> D



```

### 17. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        // Ввод количества элементов
        int n = in.nextInt();
        int[] A = new int[n];

        for (int i = 0; i < A.length; i++) {
            A[i] = in.nextInt();
        }
        
        int pos = 0; // количество положительных
        int neg = 0; // количество отрицательных
        int res = 0; // искомый индекс

        // Перебор элементов
        for (int i = 0; i < A.length; i++) {
            // Проверяем условие перед элементом i+1
            if (pos == neg) {
                res = i + 1; 
            }
            // Анализ текущего элемента
            if (A[i] > 0) pos++;
            else if (A[i] < 0) neg++;
        }
        // Вывод результата
        if (res == 1) {
            System.out.println("NO");
        } else {
            System.out.println(res);
        }
    }
}
```

###  18. Анализ правильности решения

Программа работает корректно на всем множестве решений.

1. Тест на `X > A > B > C`:

    - **Input**:
        ```
        30 15 14 13
        ```

    - **Output**:
        ```
        2
        ```
2. Тест на `X > A < B > C`:

    - **Input**:
        ```
        50 20 24 3
        ```

    - **Output**:
        ```
        3
        ```
3. Тест на `X > A < B < C`:

    - **Input**:
        ```
        40 10 12 20
        ```

    - **Output**:
        ```
        2
        ```
4. Тест на `X < A > B > C`:

    - **Input**:
        ```
        10 15 6 3
        ```

    - **Output**:
        ```
        2
        ```
5. Тест на `X < A < B < C`:

    - **Input**:
        ```
        5 6 10 13
        ```

    - **Output**:
        ```
        0
        ```
### Задача 4
### 19. Постановка задачи

> Дано множество различных положительных целых чисел, записанных в порядке возрастания. Требуется найти наибольшее по размеру подмножество, такое, что для любых двух чисел из этого подмножества одно из них делится на другое без остатка. Если существует несколько таких подмножеств одинакового размера – можно вывести любое из них.

### 20. Входные и выходные данные

#### Данные на вход

На вход программа получает две строки
Первая строка: n – число элементов множества
Вторая строка: множество из n чисел

|                   |        Тип        | min значение | max значение |
|-------------------|-------------------|--------------|--------------|
|         n         | Натуральное число |       1      |      100     |
|    a₁, a₂, … aₙ   |    Целые числа    |      −10⁹     |      10⁹     |


#### Данные на выход

На выход мы получим единственное целое положительное число.

|             |            Тип            | min значение | max значение |
|-------------|---------------------------|--------------|--------------|
|      R      |   Индекс или строка "NO"  |       1      |    100 (n)   |

### 21. Выбор структуры данных

Понадобятся следующие переменные:

|           Смысл           | Название | Тип     |
| ------------------------- | -------- | ------- |
|    Количество элементов   |    `n`   |  `int`  |
| Массив последовательности |   `A[]`  |  `int[]`|
|    Счётчик положительных  |   `pos`  |  `int`  |
|    Счётчик отрицательных  |   `neg`  |  `int`  |
|     Результат (индекс)    |   `res`  |  `int`  |



### 22. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает две строки, обозначенные как `x`, `a`, `b`, `c`.
   Затем инициализируется переменная `r = 0`, которая будет хранить количество покупателей, получивших бананы.

3. **Сравнение чисел:**  
   - Программа сравнивает значения `x` и `a`.
     1) Если `x` больше или равно `a`: программа переходит к следующему шагу для работы с `x`.
        `x = x - a`
        `r = r + 1`
     2) Если `x` меньше `a`: `x` остается без изменений
   - Программа сравнивает значения `x` и `b`. 
     1) Если `x` больше или равно `b`: программа переходит к следующему шагу для работы с `x`.
        `x = x - b`
        `r = r + 1`
     2) Если `x` меньше `b`: `x` остается без изменений
   - Программа сравнивает значения `x` и `c`. 
     1) Если `x` больше или равно `c`: программа переходит к следующему шагу для работы с `x`.
        `x = x - c`
        `r = r + 1`
     2) Если `x` меньше `c`: `x` остается без изменений

4. **Вывод результата:**  
   На экран выводится значение `r`.

#### Блок-схема

```mermaid
flowchart TD

A([Начало]) --> B[/Ввод n и массива/]
B --> C[/pos = 0, neg = 0, res = -1/]

C --> D{ i от 1 до n? }
D -->|Нет| Z([Конец])

D -->|Да| E{pos == neg?}
E -->|Да| F[res = i]
E -->|Нет| G[Пропустить]

F --> H{arr[i] > 0?}
G --> H

H -->|Да| I[pos = pos + 1]
H -->|Нет| J{arr[i] < 0?}

J -->|Да| K[neg = neg + 1]
J -->|Нет| L[Ничего не делать]

I --> M[Следующий i]
K --> M
L --> M

M --> D



```

### 23. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        // Ввод количества элементов
        int n = in.nextInt();
        int[] A = new int[n];

        for (int i = 0; i < A.length; i++) {
            A[i] = in.nextInt();
        }
        
        int pos = 0; // количество положительных
        int neg = 0; // количество отрицательных
        int res = 0; // искомый индекс

        // Перебор элементов
        for (int i = 0; i < A.length; i++) {
            // Проверяем условие перед элементом i+1
            if (pos == neg) {
                res = i + 1; 
            }
            // Анализ текущего элемента
            if (A[i] > 0) pos++;
            else if (A[i] < 0) neg++;
        }
        // Вывод результата
        if (res == 1) {
            System.out.println("NO");
        } else {
            System.out.println(res);
        }
    }
}
```

###  24. Анализ правильности решения

Программа работает корректно на всем множестве решений.

1. Тест на `X > A > B > C`:

    - **Input**:
        ```
        30 15 14 13
        ```

    - **Output**:
        ```
        2
        ```
2. Тест на `X > A < B > C`:

    - **Input**:
        ```
        50 20 24 3
        ```

    - **Output**:
        ```
        3
        ```
3. Тест на `X > A < B < C`:

    - **Input**:
        ```
        40 10 12 20
        ```

    - **Output**:
        ```
        2
        ```
4. Тест на `X < A > B > C`:

    - **Input**:
        ```
        10 15 6 3
        ```

    - **Output**:
        ```
        2
        ```
5. Тест на `X < A < B < C`:

    - **Input**:
        ```
        5 6 10 13
        ```

    - **Output**:
        ```
        0
        ```

